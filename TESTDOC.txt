This document describes a collection of user-level test programs compiled and executed on the Yalnix operating system. Each test exercises specific kernel and system call functionality, providing a means to verify correct behavior of memory allocation, process control, synchronization primitives, interprocess communication, terminal I/O, and protection mechanisms. The tests are written in C using the Yalnix user-level library (yuser.h) and are intended to demonstrate how various system calls behave under different conditions.

One of the initial tests allocates a large buffer on the stack and writes into it to ensure that the process’s address space is correctly mapped and that page faults are handled appropriately. By filling a ten-kilobyte array with a repeated character and printing out the address and content at regular intervals, this test verifies that the kernel’s virtual memory management can handle large stack allocations and that TracePrintf can be used reliably to report memory contents.

Another test focuses on condition variables and locks. In this scenario, the parent process initializes both a lock and a condition variable before forking a child. The child delays for a brief period, then signals the condition variable, while the parent acquires the lock, waits on the condition variable, and exits once signaled. This test checks that CvarWait and CvarSignal interact correctly, that the lock is appropriately released and reacquired, and that processes wake up in response to signals after being blocked.

A simpler test demonstrates the relationship between Fork, Exec, and Wait. The parent process forks a child, which then calls Exec to replace its image with another user program (often named “zero” or similar). When the child exits, the parent calls Wait to retrieve the child’s exit status and prints it via TracePrintf. This exercise confirms that Exec returns only in the parent when an error occurs, that the child inherits open file descriptors correctly, and that Wait successfully reaps the child and passes back its status code.

One test illustrates the use of Delay and Exit in conjunction with Fork and Wait. After forking, the child delays for a fixed number of clock ticks before exiting with a zero status code. The parent immediately calls Wait, ensuring it blocks until the child has finished delaying and exits. The parent then prints the exit status. This pattern ensures that the Delay system call causes a process to be blocked for the specified time and that processes can correctly synchronize via Wait until their children terminate.

A recursive program intentionally consumes stack and heap space to test memory allocation behavior under deeper call chains. Each recursion step allocates a small array on the stack and calls malloc to allocate additional heap pages, then prints a message via TtyPrintf before recursing further until a base case is reached. Both the parent and a forked child run this recursion, demonstrating that each process has its own independent stack, heap, and set of page tables. It also validates that allocation failures are handled gracefully and that TtyPrintf can be used recursively.

There are two minimalist “idle” tests that run in kernel/user modes to ensure the system remains alive when no runnable processes are ready. One is a kernel module that repeatedly executes a busy-loop pause (DoIdle), printing a message each time the CPU is halted and upon the next interrupt. The other is a user-level version that simply loops forever with a Pause call. These tests verify that Pause and the scheduler keep the CPU in an idle state until an interrupt or a higher-priority process becomes runnable.

Another test exercises lock behavior more directly. The parent initializes a lock, then forks a child. The child delays to give the parent a chance to acquire the lock, then attempts to acquire the same lock and should be blocked until the parent releases it. The parent acquires the lock immediately, delays while holding it, then releases the lock and delays further to let the child run. Both parent and child print messages at each stage, confirming that Acquire and Release function correctly to enforce mutual exclusion and that Delay and scheduling allow the child to proceed only after the lock is freed.

An interprocess communication test uses PipeInit, PipeRead, and PipeWrite to implement simple message passing. A pipe is created, then Fork is called. The parent delays briefly, writes a message string into the pipe, and exits only after the child reads the data. The child blocks on PipeRead until the data is available, null-terminates the received buffer, prints it with TracePrintf, and then exits. This exercise confirms that pipes provide reliable communication, that PipeRead blocks until there is data to read, and that PipeWrite blocks or succeeds correctly when the buffer has capacity.

A comprehensive concurrency and synchronization stress test forks multiple helper processes designed to interact via locks and condition variables, perform repeated dynamic memory operations, and generate continuous text output to various terminals. These helper processes include Bouncer, which waits on a condition variable in a loop; ThatAnnoyingPerson, which continuously writes humorous messages to a terminal; MallocMonster, which randomly allocates and frees heap pages; SonarGal, which periodically signals the condition variable; and GarbageMan, which spews random text to another terminal. The parent process waits in a long Delay loop. This complex test ensures that context switching, scheduling, lock and Cvar primitives, memory allocation, terminal I/O, and process creation scale correctly when multiple processes run concurrently and contend for resources.

A user-level TTY test program interacts with the terminal through TtyPrintf, TtyWrite, and TtyRead. It prints a welcome banner, displays the process ID, prompts the user for input, and echoes the input lines back to the terminal. This test validates that terminal output and input functionality are correctly routed no matter which terminal number is specified and that buffering, blocking on input, and correct reporting of bytes read and written work as intended.

Finally, a protection violation test deliberately attempts to write to a high, invalid memory address (for example, an address that should be unmapped in the process’s page tables). By writing to a memory location well outside the allocated segments, the program triggers a trap handled by the kernel. If the kernel correctly detects and handles protection violations, the TracePrintf call after the write will never be reached, and the process will be terminated or handled according to the policy for invalid memory accesses. This confirms that memory protection mechanisms prevent illegal writes and that fault handling redirects the process flow as specified by the Yalnix architecture.

Together, these user programs form a suite of tests to verify the correct implementation of core Yalnix features: virtual memory management, process creation and termination, scheduling, synchronization via locks and condition variables, interprocess communication with pipes, dynamic memory allocation, terminal I/O, and fault protection. By running each test and observing the printed output, one can identify any discrepancies in expected behavior and ensure that the kernel and associated libraries function reliably under various scenarios.